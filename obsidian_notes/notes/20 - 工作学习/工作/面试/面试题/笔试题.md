# 前端面试笔试题详解

## HTML & CSS 部分

### 1. 盒模型详解

盒模型是CSS中的一个基础概念，描述了元素在文档布局中所占空间的计算方式。

**标准盒模型 (Content-Box)**:
- `width` 和 `height` 只计算内容区域的尺寸
- 实际占用空间 = 内容宽度/高度 + padding + border + margin
- 在CSS中对应 `box-sizing: content-box`（默认值）

**IE盒模型 (Border-Box)**:
- `width` 和 `height` 包含内容区域、padding和border
- 实际占用空间 = 设定的宽度/高度 + margin
- 在CSS中对应 `box-sizing: border-box`

**示例代码**:
```css
/* 标准盒模型 */
.standard-box {
  box-sizing: content-box;
  width: 100px;
  height: 100px;
  padding: 10px;
  border: 5px solid black;
  margin: 15px;
  /* 实际宽度 = 100px + 10px*2 + 5px*2 = 130px */
}

/* IE盒模型 */
.ie-box {
  box-sizing: border-box;
  width: 100px;
  height: 100px;
  padding: 10px;
  border: 5px solid black;
  margin: 15px;
  /* 实际内容宽度 = 100px - 10px*2 - 5px*2 = 70px */
}
```

**应用场景**:
- 标准盒模型适合需要精确控制内容区域大小的场景
- IE盒模型适合需要精确控制元素整体大小的场景，在响应式设计中更为常用

### 2. CSS选择器优先级详解

CSS选择器优先级决定了当多个规则应用于同一元素时，哪一个规则会被最终采用。

**完整优先级计算规则**:
1. `!important` 声明最高（应谨慎使用）
2. 内联样式 (1000分)
3. ID选择器 (100分)
4. 类选择器、属性选择器、伪类选择器 (10分)
5. 元素选择器、伪元素选择器 (1分)
6. 通配符选择器 (0分)
7. 继承的样式 (无优先级)

**计算方法**:
计算一个选择器的优先级时，将不同类型的选择器数量分别计数，然后按权重相加：
- 内联样式计为 1,0,0,0
- 每个ID选择器计为 0,1,0,0
- 每个类/属性/伪类选择器计为 0,0,1,0
- 每个元素/伪元素选择器计为 0,0,0,1

**举例**:
```css
/* 优先级: 0,0,0,1 */
p { color: black; }

/* 优先级: 0,0,1,0 */
.text { color: red; }

/* 优先级: 0,1,0,0 */
#header { color: blue; }

/* 优先级: 0,0,1,1 */
p.text { color: green; }

/* 优先级: 0,1,0,1 */
#header p { color: yellow; }

/* 优先级: 0,1,1,0 */
#header .text { color: purple; }

/* 优先级: 0,0,2,0 */
.nav.dropdown { color: orange; }
```

**特殊规则**:
- 如果优先级相同，则后声明的样式覆盖先声明的样式
- `:not()`伪类本身不增加优先级，但其参数会计入优先级计算

### 3. 水平垂直居中的详细实现方法

#### Flexbox方法（最现代且灵活）

```css
.container {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center;     /* 垂直居中 */
  height: 300px;           /* 容器需要有高度 */
}
```

优点：
- 响应式，适应内容大小变化
- 多个子元素也能同时居中
- 支持所有现代浏览器

#### Grid方法（代码最简洁）

```css
.container {
  display: grid;
  place-items: center;    /* 水平和垂直居中的简写 */
  /* 等同于: */
  /* justify-items: center; */
  /* align-items: center; */
  height: 300px;
}
```

优点：
- 语法简洁
- 对任何元素都有效

#### 绝对定位 + transform（兼容性好）

```css
.container {
  position: relative;
  height: 300px;
}

.centered {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* 向左上偏移自身尺寸的一半 */
}
```

优点：
- 不需要知道子元素的尺寸
- 浏览器兼容性好

#### 绝对定位 + margin: auto（简单，但需已知尺寸）

```css
.container {
  position: relative;
  height: 300px;
}

.centered {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  width: 100px;  /* 必须设置宽高 */
  height: 100px;
}
```

优点：
- 实现简单
- 浏览器兼容性好

缺点：
- 必须预先知道子元素的尺寸

#### table-cell方法（传统布局）

```css
.container {
  display: table-cell;
  text-align: center;    /* 水平居中 */
  vertical-align: middle; /* 垂直居中 */
  height: 300px;
  width: 300px;
}

.centered {
  display: inline-block; /* 对行内元素生效 */
}
```

优点：
- 兼容较老的浏览器
- 内容的大小可以动态改变

### 4. 清除浮动的几种方法

浮动元素会脱离文档流，可能导致父容器无法正确计算高度，这是"高度塌陷"问题。

**方法1: 使用clearfix伪元素**
```css
.clearfix::after {
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
  height: 0;
}
```

**方法2: 父元素添加overflow属性**
```css
.container {
  overflow: auto; /* 或 hidden */
}
```

**方法3: 使用clear属性的空元素**
```html
<div class="container">
  <div class="float-element">浮动元素</div>
  <div style="clear: both;"></div>
</div>
```

**方法4: 父元素也设为浮动**
```css
.container {
  float: left;
  width: 100%; /* 确保占据整行 */
}
```

**方法5: 使用display: flow-root (现代方法)**
```css
.container {
  display: flow-root;
}
```

## JavaScript 部分

### 5. var、let 和 const 的详细对比

#### var 特性
- **函数作用域**: 变量在声明它的函数内部可见
- **变量提升**: 声明会被提升到作用域顶部，但赋值不会
- **可重复声明**: 同一作用域内可以多次声明同一变量
- **全局变量**: 在顶层作用域声明会成为全局对象(window)的属性

```javascript
function example() {
  console.log(x); // 输出: undefined (而非报错)
  var x = 10;
  var x = 20; // 允许重复声明
}

console.log(typeof x); // 'undefined'，函数外无法访问
```

#### let 特性
- **块级作用域**: 变量仅在声明它的代码块内可见
- **无变量提升**: 存在"暂时性死区"(TDZ)，在声明前无法访问
- **不可重复声明**: 同一作用域内不可多次声明
- **不绑定全局对象**: 在顶层作用域声明不会成为全局对象的属性

```javascript
function example() {
  // console.log(x); // 会报错: ReferenceError
  let x = 10;
  // let x = 20; // 会报错: SyntaxError
  
  if (true) {
    let x = 30; // 不同作用域，允许声明同名变量
    console.log(x); // 30
  }
  
  console.log(x); // 10
}
```

#### const 特性
- 与let具有相同的作用域规则
- **声明时必须初始化**: 必须在声明时赋值
- **不可重新赋值**: 赋值后不能改变引用
- **对象内容可变**: 如果值是对象，其属性仍可以修改

```javascript
const PI = 3.14159;
// PI = 3; // 会报错: TypeError

const obj = { name: "John" };
obj.name = "Jane"; // 有效，对象属性可以修改
// obj = {}; // 会报错: TypeError，不能重新赋值

const arr = [1, 2, 3];
arr.push(4); // 有效
arr[0] = 0; // 有效
// arr = []; // 会报错: TypeError
```

#### 最佳实践建议
- 默认使用 `const`
- 当变量需要重新赋值时使用 `let`
- 避免使用 `var`

### 6. 闭包的详细解析

闭包是JavaScript中的一个核心概念，指函数可以记住并访问其词法作用域，即使该函数在其词法作用域之外执行。

**闭包形成的条件**:
1. 函数嵌套
2. 内部函数引用外部函数的变量
3. 内部函数在外部函数作用域之外被调用

**基本示例**:
```javascript
function createCounter() {
  let count = 0; // 私有变量
  
  return function increment() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

**闭包的实际应用场景**:

1. **数据封装和私有变量**
```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // 私有变量
  
  return {
    deposit: function(amount) {
      balance += amount;
      return balance;
    },
    withdraw: function(amount) {
      if (amount > balance) {
        throw new Error('余额不足');
      }
      balance -= amount;
      return balance;
    },
    getBalance: function() {
      return balance;
    }
  };
}

const account = createBankAccount(1000);
account.deposit(500); // 1500
account.withdraw(200); // 1300
account.getBalance(); // 1300
// 无法直接访问或修改balance变量
```

2. **函数工厂**
```javascript
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

3. **实现单例模式**
```javascript
const Singleton = (function() {
  let instance;
  
  function createInstance() {
    return {
      name: 'Singleton Instance',
      method() {
        console.log('Method called');
      }
    };
  }
  
  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true
```

4. **事件处理和回调**
```javascript
function setupButton(buttonId, message) {
  const button = document.getElementById(buttonId);
  button.addEventListener('click', function() {
    // 闭包捕获了外部函数的message变量
    alert(message);
  });
}

setupButton('btn1', 'Button 1 clicked');
setupButton('btn2', 'Button 2 clicked');
```

**闭包的注意事项**:

1. **内存消耗**: 闭包会保留对外部变量的引用，可能导致内存泄漏
2. **性能影响**: 过度使用闭包可能影响性能
3. **作用域链**: 闭包可以访问外部所有嵌套作用域中的变量

### 7. Promise及异步编程详解

#### Promise基础

Promise是JavaScript中处理异步操作的对象，代表一个尚未完成但预期将来会完成的操作。

**Promise的三种状态**:
- `pending`: 初始状态，既未完成也未拒绝
- `fulfilled`: 操作成功完成
- `rejected`: 操作失败

**基本用法**:
```javascript
const promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    const randomNum = Math.random();
    if (randomNum > 0.5) {
      resolve(`成功: ${randomNum}`);  // 成功时调用
    } else {
      reject(`失败: ${randomNum}`);   // 失败时调用
    }
  }, 1000);
});

promise
  .then(result => {
    console.log('成功结果:', result);
    return result + ' 处理后';  // 返回值会被包装为Promise
  })
  .then(processedResult => {
    console.log('处理后结果:', processedResult);
  })
  .catch(error => {
    console.error('错误:', error);
  })
  .finally(() => {
    console.log('无论成功失败都会执行');
  });
```

#### Promise常用方法

**Promise.all()**
等待所有Promise完成，或有一个被拒绝。
```javascript
const promise1 = Promise.resolve(1);
const promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 1000));
const promise3 = fetch('https://api.example.com/data').then(res => res.json());

Promise.all([promise1, promise2, promise3])
  .then(values => {
    console.log('所有Promise完成:', values); // [1, 2, data]
  })
  .catch(error => {
    console.error('至少一个Promise失败:', error);
  });
```

**Promise.race()**
返回最先完成的Promise结果，无论成功或失败。
```javascript
const promise1 = new Promise(resolve => setTimeout(() => resolve('结果1'), 500));
const promise2 = new Promise(resolve => setTimeout(() => resolve('结果2'), 100));

Promise.race([promise1, promise2])
  .then(value => console.log('最快的结果:', value)) // '结果2'
  .catch(error => console.error('最快的错误:', error));
```

**Promise.allSettled()**
等待所有Promise完成，无论成功失败。
```javascript
const promises = [
  Promise.resolve('成功'),
  Promise.reject('失败'),
  new Promise(resolve => setTimeout(() => resolve('延迟成功'), 1000))
];

Promise.allSettled(promises)
  .then(results => {
    // results是一个对象数组，每个对象包含status和value/reason
    console.log(results);
    // [
    //   {status: "fulfilled", value: "成功"},
    //   {status: "rejected", reason: "失败"},
    //   {status: "fulfilled", value: "延迟成功"}
    // ]
  });
```

**Promise.any()**
返回第一个成功的Promise结果，只有全部失败才会拒绝。
```javascript
const promises = [
  new Promise((resolve, reject) => setTimeout(() => reject('Error 1'), 100)),
  new Promise((resolve) => setTimeout(() => resolve('Success'), 200)),
  new Promise((resolve) => setTimeout(() => resolve('Also Success'), 300))
];

Promise.any(promises)
  .then(value => console.log('第一个成功结果:', value)) // 'Success'
  .catch(error => console.error('全部失败:', error));
```

#### async/await

async/await是基于Promise的语法糖，让异步代码看起来更像同步代码。

**基本用法**:
```javascript
async function fetchUserData(userId) {
  try {
    // await暂停函数执行，直到Promise解决
    const response = await fetch(`https://api.example.com/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }
    
    const userData = await response.json();
    return userData;
  } catch (error) {
    console.error('获取用户数据失败:', error);
    throw error; // 重新抛出错误，调用者可以捕获
  }
}

// 使用async函数
async function displayUserInfo(userId) {
  try {
    const user = await fetchUserData(userId);
    console.log(`用户名: ${user.name}, 邮箱: ${user.email}`);
  } catch (error) {
    console.log('显示用户信息失败:', error);
  }
}

// 异步函数返回Promise，可以用Promise方式调用
fetchUserData(123)
  .then(user => console.log(user))
  .catch(error => console.error(error));
```

**并行执行**:
```javascript
async function fetchMultipleResources() {
  // 同时开始所有请求
  const userPromise = fetch('https://api.example.com/user').then(r => r.json());
  const postsPromise = fetch('https://api.example.com/posts').then(r => r.json());
  const commentsPromise = fetch('https://api.example.com/comments').then(r => r.json());
  
  // 等待所有请求完成
  const [user, posts, comments] = await Promise.all([
    userPromise, postsPromise, commentsPromise
  ]);
  
  return { user, posts, comments };
}
```

**错误处理**:
```javascript
// 为每个await单独添加try/catch
async function robustFetch() {
  try {
    const data1 = await fetchFirstResource();
  } catch (error) {
    console.log('获取第一个资源失败，使用备用数据');
    data1 = backupData;
  }
  
  try {
    const data2 = await fetchSecondResource(data1);
    return data2;
  } catch (error) {
    return defaultResult;
  }
}
```

### 8. 事件委托原理与实现详解

事件委托(Event Delegation)是一种利用事件冒泡机制，在父元素上统一处理子元素事件的技术。

**原理**:
1. 事件冒泡：当事件在子元素上触发后，会逐级向上传递到父元素
2. 事件对象：event对象的target属性指向实际触发事件的元素

**优点**:
- 减少事件处理器数量，提高性能
- 动态添加的元素也能响应事件，无需重新绑定
- 内存占用更小
- 简化代码管理

**基本实现**:
```javascript
document.getElementById('parent').addEventListener('click', function(event) {
  // 检查事件源元素
  if (event.target.matches('.child')) {
    console.log('子元素被点击:', event.target);
    // 处理子元素点击事件
  }
});
```

**完整示例**:
```javascript
// HTML结构
// <ul id="todo-list">
//   <li class="todo-item" data-id="1">任务1 <button class="delete">删除</button></li>
//   <li class="todo-item" data-id="2">任务2 <button class="delete">删除</button></li>
// </ul>

const todoList = document.getElementById('todo-list');

todoList.addEventListener('click', function(event) {
  // 使用closest方法找到被点击的最近的.todo-item元素
  const todoItem = event.target.closest('.todo-item');
  
  // 如果点击的是删除按钮
  if (event.target.matches('.delete')) {
    const itemId = todoItem.dataset.id;
    console.log(`删除任务${itemId}`);
    todoItem.remove();
    event.preventDefault(); // 阻止默认行为
    event.stopPropagation(); // 阻止进一步冒泡
  } 
  // 如果直接点击任务项
  else if (todoItem) {
    console.log(`选中任务${todoItem.dataset.id}`);
    todoItem.classList.toggle('completed');
  }
});

// 动态添加新任务，无需额外绑定事件
function addNewTask(text, id) {
  const li = document.createElement('li');
  li.className = 'todo-item';
  li.dataset.id = id;
  li.innerHTML = `${text} <button class="delete">删除</button>`;
  todoList.appendChild(li);
}

addNewTask('新任务', 3); // 自动享有事件处理能力
```

**复杂场景处理**:
```javascript
function delegateEvent(element, eventType, selector, handler) {
  element.addEventListener(eventType, function(event) {
    const potentialElements = document.querySelectorAll(selector);
    
    let target = event.target;
    
    for (let i = 0, len = potentialElements.length; i < len; i++) {
      let el = potentialElements[i];
      
      // 检查触发事件的元素是否匹配或者是指定选择器元素的子元素
      let current = target;
      while (current) {
        if (current === el) {
          handler.call(current, event);
          break;
        }
        current = current.parentNode;
        if (current === element) break;
      }
    }
  });
}

// 使用方法
delegateEvent(
  document.body,
  'click',
  '.button',
  function(event) {
    console.log('按钮被点击:', this.textContent);
  }
);
```

### 9. 防抖和节流函数详细实现

防抖(Debounce)和节流(Throttle)是控制函数执行频率的两种方法，常用于优化高频事件如滚动、调整窗口大小、输入等。

#### 防抖函数详解

防抖函数确保函数延迟一定时间后才执行，如果在延迟时间内再次调用，则重置定时器。

**基本实现**:
```javascript
function debounce(fn, delay) {
  let timer = null;
  
  return function(...args) {
    // 保存this上下文
    const context = this;
    
    // 清除之前的定时器
    if (timer) clearTimeout(timer);
    
    // 设置新的定时器
    timer = setTimeout(() => {
      fn.apply(context, args);
      timer = null;
    }, delay);
  };
}
```

**增强版防抖函数(带立即执行选项)**:
```javascript
function enhancedDebounce(fn, delay, immediate = false) {
  let timer = null;
  
  return function(...args) {
    const context = this;
    const callNow = immediate && !timer;
    
    // 清除之前的定时器
    if (timer) clearTimeout(timer);
    
    timer = setTimeout(() => {
      timer = null;
      if (!immediate) fn.apply(context, args);
    }, delay);
    
    // 立即执行选项
    if (callNow) fn.apply(context, args);
  };
}
```

**防抖函数应用场景**:
- 搜索框输入，等用户输入完成后才发送请求
- 表单验证，用户停止输入一段时间后再验证
- 窗口调整大小结束后再执行操作

```javascript
// 搜索框防抖示例
const searchInput = document.getElementById('search');
const searchHandler = debounce(function(e) {
  console.log('搜索内容:', e.target.value);
  // 发送API请求
}, 500);

searchInput.addEventListener('input', searchHandler);
```

#### 节流函数详解

节流函数确保在指定时间内只执行一次函数，无论调用多少次。

**基本实现(使用时间戳)**:
```javascript
function throttle(fn, interval) {
  let lastTime = 0;
  
  return function(...args) {
    const context = this;
    const now = Date.now();
    
    if (now - lastTime >= interval) {
      fn.apply(context, args);
      lastTime = now;
    }
  };
}
```

**使用定时器实现**:
```javascript
function timerThrottle(fn, interval) {
  let timer = null;
  
  return function(...args) {
    const context = this;
    
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(context, args);
        timer = null;
      }, interval);
    }
  };
}
```

**综合实现(兼顾首尾调用)**:
```javascript
function advancedThrottle(fn, interval, options = {}) {
  const { leading = true, trailing = true } = options;
  let lastTime = 0;
  let timer = null;
  
  return function(...args) {
    const context = this;
    const now = Date.now();
    
    // 如果禁用第一次执行
    if (lastTime === 0 && leading === false) {
      lastTime = now;
    }
    
    const remaining = interval - (now - lastTime);
    
    // 如果已经到了间隔时间，可以执行
    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      
      fn.apply(context, args);
      lastTime = now;
    } 
    // 否则设置定时器确保最后一次也能执行
    else if (trailing && !timer) {
      timer = setTimeout(() => {
        // 重置lastTime，重要！
        lastTime = leading ? Date.now() : 0;
        timer = null;
        fn.apply(context, args);
      }, remaining);
    }
  };
}
```

**节流函数应用场景**:
- 滚动事件处理
- 拖拽操作
- 游戏中的按键控制
- 频繁点击按钮

```javascript
// 滚动事件节流示例
const handleScroll = throttle(function() {
  console.log('窗口滚动到:', window.scrollY);
  // 执行滚动相关操作
}, 200);

window.addEventListener('scroll', handleScroll);
```

### 10. 深拷贝与浅拷贝实现

#### 浅拷贝实现

浅拷贝只复制对象的第一层属性，对于嵌套对象，只复制引用。

**方法1: 使用Object.assign()**
```javascript
function shallowCopy(obj) {
  return Object.assign({}, obj);
}

// 或直接使用
const copy = Object.assign({}, original);
```

**方法2: 使用展开运算符**
```javascript
const original = { a: 1, b: { c: 2 } };
const copy = { ...original };
```

**方法3: 手动实现**
```javascript
function shallowCopy(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;
  
  const newObj = Array.isArray(obj) ? [] : {};
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = obj[key];
    }
  }
  
  return newObj;
}
```

#### 深拷贝实现

深拷贝会递归复制所有嵌套对象，创建完全独立的副本。

**方法1: JSON方法(简单但有局限)**
```javascript
function jsonDeepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
```
限制：不能处理函数、正则、Symbol、循环引用等。

**方法2: 递归实现**
```javascript
function deepCopy(obj, hash = new WeakMap()) {
  //# 前端面试笔试题详解（续）

## JavaScript 部分（续）

### 10. 深拷贝与浅拷贝实现（续）

#### 深拷贝实现（续）

**方法2: 递归实现**
```javascript
function deepCopy(obj, hash = new WeakMap()) {
  // 处理基本类型和null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理日期对象
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理正则对象
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 创建新的数组或对象
  const newObj = Array.isArray(obj) ? [] : {};
  
  // 将当前对象添加到哈希表
  hash.set(obj, newObj);
  
  // 递归复制所有属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = deepCopy(obj[key], hash);
    }
  }
  
  return newObj;
}
```

**方法3: 处理更多特殊类型**
```javascript
function completeDeepCopy(obj, hash = new WeakMap()) {
  // 处理基本类型和null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 检查循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 处理特殊对象类型
  let result;
  
  // 处理日期
  if (obj instanceof Date) {
    result = new Date(obj);
    hash.set(obj, result);
    return result;
  }
  
  // 处理正则
  if (obj instanceof RegExp) {
    result = new RegExp(obj.source, obj.flags);
    hash.set(obj, result);
    return result;
  }
  
  // 处理Map
  if (obj instanceof Map) {
    result = new Map();
    hash.set(obj, result);
    obj.forEach((value, key) => {
      result.set(completeDeepCopy(key, hash), completeDeepCopy(value, hash));
    });
    return result;
  }
  
  // 处理Set
  if (obj instanceof Set) {
    result = new Set();
    hash.set(obj, result);
    obj.forEach(value => {
      result.add(completeDeepCopy(value, hash));
    });
    return result;
  }
  
  // 处理数组和普通对象
  result = Array.isArray(obj) ? [] : {};
  hash.set(obj, result);
  
  // 获取所有属性，包括不可枚举的
  const allProps = [...Object.getOwnPropertyNames(obj), ...Object.getOwnPropertySymbols(obj)];
  
  allProps.forEach(key => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key);
    
    // 如果属性有getter/setter，需要保留
    if (descriptor.get || descriptor.set) {
      Object.defineProperty(result, key, descriptor);
    } else {
      result[key] = completeDeepCopy(obj[key], hash);
    }
  });
  
  return result;
}
```

**使用示例与测试**:
```javascript
const original = {
  name: 'John',
  info: {
    age: 30,
    address: {
      city: 'New York'
    }
  },
  hobbies: ['reading', 'swimming'],
  date: new Date(),
  regexp: /test/gi,
  func: function() { console.log('Hello') },
  [Symbol('id')]: 123,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3])
};

// 创建循环引用
original.self = original;

const deepCopied = completeDeepCopy(original);

// 修改深拷贝不影响原对象
deepCopied.info.age = 31;
deepCopied.hobbies.push('coding');

console.log(original.info.age); // 30
console.log(original.hobbies.length); // 2
```

### 11. 原型链与继承的详细实现

JavaScript中的继承主要通过原型链实现。理解原型链是理解JavaScript继承机制的关键。

#### 原型链基础

每个JavaScript对象都有一个内部链接指向另一个对象，称为原型（prototype）。该原型对象也有自己的原型，形成一个链，直到达到null。

```javascript
// 构造函数
function Person(name) {
  this.name = name;
}

// 在原型上定义方法
Person.prototype.sayHello = function() {
  return `Hello, I'm ${this.name}`;
};

// 创建实例
const john = new Person('John');

// 原型链示意
console.log(john.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true

// 方法查找
console.log(john.sayHello()); // "Hello, I'm John"
console.log(john.toString()); // 从Object.prototype继承的方法
```

#### 继承实现方式

##### 1. 原型链继承

```javascript
function Animal(name) {
  this.name = name;
  this.colors = ['black', 'white'];
}

Animal.prototype.getInfo = function() {
  return `Animal: ${this.name}`;
};

function Dog(name, breed) {
  this.breed = breed;
}

// 设置原型链
Dog.prototype = new Animal();
// 修复constructor
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  return 'Woof!';
};

const dog = new Dog('Rex', 'German Shepherd');
console.log(dog.getInfo()); // "Animal: undefined" (因为没有传name)
console.log(dog.bark()); // "Woof!"
```

**缺点**:
- 父类实例属性变成子类原型属性，导致所有子类实例共享引用
- 创建子类实例时无法向父类构造函数传参

##### 2. 构造函数继承

```javascript
function Animal(name) {
  this.name = name;
  this.colors = ['black', 'white'];
}

Animal.prototype.getInfo = function() {
  return `Animal: ${this.name}`;
};

function Dog(name, breed) {
  // 调用父类构造函数
  Animal.call(this, name);
  this.breed = breed;
}

const dog = new Dog('Rex', 'German Shepherd');
console.log(dog.name); // "Rex"
console.log(dog.colors); // ["black", "white"]
// console.log(dog.getInfo()); // Error: getInfo is not a function
```

**缺点**:
- 无法继承父类原型上的方法
- 方法在每个实例上创建，无法复用

##### 3. 组合继承

```javascript
function Animal(name) {
  this.name = name;
  this.colors = ['black', 'white'];
}

Animal.prototype.getInfo = function() {
  return `Animal: ${this.name}`;
};

function Dog(name, breed) {
  // 继承属性
  Animal.call(this, name);
  this.breed = breed;
}

// 继承方法
Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  return 'Woof!';
};

const dog = new Dog('Rex', 'German Shepherd');
console.log(dog.getInfo()); // "Animal: Rex"
console.log(dog.bark()); // "Woof!"

// 修改不影响其他实例
dog.colors.push('brown');
const anotherDog = new Dog('Max', 'Labrador');
console.log(anotherDog.colors); // ["black", "white"]
```

**缺点**:
- 调用了两次父类构造函数

##### 4. 原型式继承

```javascript
function object(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}

const animal = {
  name: 'Animal',
  colors: ['black', 'white'],
  getInfo: function() {
    return `Animal: ${this.name}`;
  }
};

const dog = object(animal);
dog.name = 'Dog';
dog.breed = 'Unknown';

console.log(dog.getInfo()); // "Animal: Dog"
```

ES5提供了`Object.create()`方法实现此功能：
```javascript
const dog = Object.create(animal);
```

**缺点**:
- 引用类型属性共享问题

##### 5. 寄生式继承

```javascript
function createAnother(original) {
  const clone = Object.create(original);
  clone.bark = function() {
    return 'Woof!';
  };
  return clone;
}

const animal = {
  name: 'Animal',
  getInfo: function() {
    return `Animal: ${this.name}`;
  }
};

const dog = createAnother(animal);
console.log(dog.getInfo()); // "Animal: Animal"
console.log(dog.bark()); // "Woof!"
```

##### 6. 寄生组合式继承（最优方案）

```javascript
function inheritPrototype(child, parent) {
  // 创建父类原型的副本
  const prototype = Object.create(parent.prototype);
  // 增强对象
  prototype.constructor = child;
  // 指定对象为子类的原型
  child.prototype = prototype;
}

function Animal(name) {
  this.name = name;
  this.colors = ['black', 'white'];
}

Animal.prototype.getInfo = function() {
  return `Animal: ${this.name}`;
};

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

inheritPrototype(Dog, Animal);

Dog.prototype.bark = function() {
  return 'Woof!';
};

const dog = new Dog('Rex', 'German Shepherd');
console.log(dog.getInfo()); // "Animal: Rex"
console.log(dog.bark()); // "Woof!"
```

##### 7. ES6 Class继承

现代JavaScript中，可以使用ES6的class语法更优雅地实现继承：

```javascript
class Animal {
  constructor(name) {
    this.name = name;
    this.colors = ['black', 'white'];
  }
  
  getInfo() {
    return `Animal: ${this.name}`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 调用父类构造函数
    this.breed = breed;
  }
  
  bark() {
    return 'Woof!';
  }
  
  // 重写父类方法
  getInfo() {
    return `${super.getInfo()}, Breed: ${this.breed}`;
  }
}

const dog = new Dog('Rex', 'German Shepherd');
console.log(dog.getInfo()); // "Animal: Rex, Breed: German Shepherd"
```

## 框架相关

### 12. React中虚拟DOM的详细工作原理

虚拟DOM(Virtual DOM)是React核心概念之一，它是一种内存中的DOM表示方法，通过将实际DOM操作差异化和批量化来提高性能。

#### 虚拟DOM的基本概念

1. **什么是虚拟DOM**：
   - 虚拟DOM是真实DOM的JavaScript对象表示
   - 它是轻量级的，可以在内存中快速创建和操作
   - 每个DOM元素都有对应的虚拟DOM对象

```javascript
// 真实DOM
<div class="container">
  <p>文本内容</p>
  <button>点击</button>
</div>

// 对应的虚拟DOM（简化表示）
{
  type: 'div',
  props: {
    className: 'container',
    children: [
      {
        type: 'p',
        props: {
          children: '文本内容'
        }
      },
      {
        type: 'button',
        props: {
          children: '点击'
        }
      }
    ]
  }
}
```

#### 工作流程详解

1. **初始渲染过程**：
   - 创建虚拟DOM树
   - 从虚拟DOM生成真实DOM
   - 将真实DOM插入到页面中

2. **更新过程**：
   - 当状态(state)或属性(props)变化时，生成新的虚拟DOM树
   - 与旧的虚拟DOM树进行对比（Diffing）
   - 计算出DOM的最小变更
   - 批量更新真实DOM
   
```
[状态变化] → [新虚拟DOM] → [Diffing算法] → [计算最小变更] → [更新实际DOM]
```

#### Diffing算法详解

React的Diffing算法是一种启发式算法，复杂度为O(n)，而非传统的O(n³)，主要基于两个假设：

1. **同类型组件生成相似DOM结构，不同类型组件生成不同DOM结构**
2. **同一层级的子节点可以通过key来优化更新**

**Diff的三个层次**：

1. **树级比较(Tree Diff)**：
   - 两个不同类型的元素会生成不同的树
   - 当检测到不同类型的元素时，React会直接替换整个子树

```javascript
// 前: <div><Counter /></div>
// 后: <span><Counter /></span>

// React会销毁Counter实例及其整个子树，重新创建新的实例
```

2. **组件级比较(Component Diff)**：
   - 同类型组件通过props更新内部变量实现虚拟DOM的复用
   - 不同类型组件直接替换

```javascript
// 前: <Counter value={1} />
// 后: <Counter value={2} />

// React保留组件实例，只更新props

// 前: <Counter />
// 后: <Timer />

// React卸载Counter，装载Timer
```

3. **元素级比较(Element Diff)**：
   - 同一层级的子节点通过key进行优化
   - 无key时采用简单的顺序对比

```jsx
// 无key的情况下，顺序变化会导致大量DOM操作
<ul>
  <li>项目1</li>
  <li>项目2</li>
</ul>

<ul>
  <li>项目2</li>
  <li>项目1</li>
</ul>
```

**使用key的优化**：
```jsx
// 使用key，React能识别移动操作，减少DOM操作
<ul>
  <li key="1">项目1</li>
  <li key="2">项目2</li>
</ul>

<ul>
  <li key="2">项目2</li>
  <li key="1">项目1</li>
</ul>
```

#### 虚拟DOM的优势

1. **性能优化**：
   - 批量处理DOM更新
   - 减少实际DOM操作次数
   - 避免布局抖动(layout thrashing)

2. **跨平台能力**：
   - 同一套虚拟DOM可以渲染为不同平台的UI (Web、原生移动应用)
   - 支持服务器端渲染(SSR)

3. **声明式编程**：
   - 开发者描述UI应该是什么样子，而不是如何去更新

#### Fiber架构

React 16引入了Fiber架构，进一步增强虚拟DOM的能力：

1. **可中断的渲染过程**：
   - 将渲染工作分割成小单元
   - 可以暂停、恢复和丢弃渲染工作

2. **优先级处理**：
   - 为不同类型的更新分配优先级
   - 优先处理用户交互等高优先级更新

3. **并发模式**：
   - 同时准备多个版本的UI
   - 根据最新数据"提交"最终版本

```javascript
// Fiber节点结构(简化)
{
  type: 'div',            // DOM元素类型
  key: null,              // key属性
  stateNode: domElement,  // 对应的DOM节点
  
  // Fiber关系
  return: parentFiber,    // 父Fiber
  child: childFiber,      // 第一个子Fiber
  sibling: nextFiber,     // 下一个兄弟Fiber
  
  // 副作用
  effectTag: 'PLACEMENT',  // 需要执行的DOM操作
  nextEffect: nextFiber    // 下一个有副作用的Fiber
}
```

### 13. Vue的响应式原理详解

Vue的响应式系统是其最核心的特性之一，允许数据与视图保持同步。Vue 2和Vue 3使用不同的实现方式。

#### Vue 2 响应式原理

Vue 2使用`Object.defineProperty()`来劫持对象属性的getter和setter。

**基本流程**:

1. **初始化数据**：Vue在实例化时，对data对象的属性进行处理

2. **转换为getter/setter**：使用`Object.defineProperty()`将属性转换为getter/setter

3. **依赖收集**：在属性被访问(getter)时收集依赖

4. **派发更新**：在属性被修改(setter)时通知依赖更新

**简化版实现**:
```javascript
// 观察者模式 - 发布订阅中心
class Dep {
  constructor() {
    this.subscribers = new Set(); // 订阅者集合
  }
  
  depend() {
    if (activeEffect) {
      this.subscribers.add(activeEffect);
    }
  }
  
  notify() {
    this.subscribers.forEach(effect => effect());
  }
}

// 将普通对象转换为响应式对象
function observe(obj) {
  Object.keys(obj).forEach(key => {
    let value = obj[key];
    const dep = new Dep();
    
    // 如果值也是对象，递归处理
    if (typeof value === 'object' && value !== null) {
      observe(value);
    }
    
    Object.defineProperty(obj, key, {
      get() {
        dep.depend(); // 收集依赖
        return value;
      },
      set(newValue) {
        if (value === newValue) return;
        value = newValue;
        
        // 如果新值是对象，也要转换为响应式
        if (typeof newValue === 'object' && newValue !== null) {
          observe(newValue);
        }
        
        dep.notify(); // 通知更新
      }
    });
  });
  
  return obj;
}

let activeEffect = null; // 当前激活的效果函数

function watchEffect(effect) {
  activeEffect = effect;
  effect(); // 首次执行以收集依赖
  activeEffect = null;
}

// 使用示例
const state = observe({
  count: 0,
  user: { name: 'John' }
});

watchEffect(() => {
  console.log('Count changed:', state.count);
});

state.count++; // 触发日志：Count changed: 1
```

**Vue 2响应式系统的缺点**:

1. **无法检测对象属性的添加和删除**:
```javascript
const vm = new Vue({
  data: { user: { name: 'John' } }
});

// 这不会触发更新
vm.user.age = 30;

// 解决方法
Vue.set(vm.user, 'age', 30);
// 或
vm.$set(vm.user, 'age', 30);
```

2. **无法直接检测数组的变化**:
```javascript
const vm = new Vue({
  data: { items: [1, 2, 3] }
});

// 这不会触发更新
vm.items[0] = 10;

// 解决方法
Vue.set(vm.items, 0, 10);
// 或使用变异方法
vm.items.splice(0, 1, 10);
```

3. **性能消耗**：需要递归遍历对象的所有属性

#### Vue 3 响应式原理

Vue 3使用ES6的Proxy代替Object.defineProperty，这带来了很多优势。

**基本流程**:

1. **代理整个对象**：使用Proxy创建原始对象的代理

2. **拦截对象操作**：拦截属性访问、修改、添加、删除等操作

3. **依赖追踪**：使用一个新的响应式系统(reactivity)

**简化版实现**:
```javascript
// 响应式系统
let activeEffect;
const targetMap = new WeakMap(); // 存储依赖关系

function track(target, key) {
  if (!activeEffect) return;
  
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  
  dep.add(activeEffect);
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

function reactive(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);
      track(target, key); // 依赖收集
      
      // 嵌套对象的响应式处理
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }
      
      return result;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);
      
      if (oldValue !== value) {
        trigger(target, key); // 触发更新
      }
      
      return result;
    },
    deleteProperty(target, key) {
      const hadKey = key in target;
      const result = Reflect.deleteProperty(target, key);
      
      if (hadKey && result) {
        trigger(target, key); // 删除属性也触发更新
      }
      
      return result;
    }
  });
}

function effect(fn) {
  activeEffect = fn;
  fn(); // 首次执行，进行依赖收集
  activeEffect = null;
  return fn;
}

// 使用示例
const state = reactive({
  count: 0,
  user: { name: 'John' }
});

effect(() => {
  console.log('Count is:', state.count);
});

effect(() => {
  console.log('User name is:', state.user.name);
});

// 这些操作都会触发响应式更新
state.count++;
state.user.name = 'Jane';
state.user.age = 30; // 新属性也是响应式的
delete state.count;  // 删除也会触发更新
```

**Vue 3响应式系统的优势**:

1. **监听整个对象**：可以监听对象的添加、删除属性操作
2. **数组操作的完整支持**：可以直接通过索引修改数组
3. **性能改进**：惰性监听，首次访问时才会进行递归代理
4. **更好的TypeScript支持**
5. **支持更多数据结构**：Map、Set等

**Vue 3 Composition API**:

Vue 3引入了Composition API，可以更灵活地组织和重用逻辑：

```javascript
import { ref, reactive, computed, watch, onMounted } from 'vue';

export default {
  setup() {
    // ref用于基本类型的响应式
    const count = ref(0);
    
    // reactive用于对象的响应式
    const user = reactive({
      name: 'John',
      age: 30
    });
    
    // 计算属性
    const doubleCount = computed(() => count.value * 2);
    
    // 侦听器
    watch(count, (newValue, oldValue) => {
      console.log(`Count changed from ${oldValue} to ${newValue}`);
    });
    
    // 生命周期钩子
    onMounted(() => {
      console.log('Component mounted');
    });
    
    // 方法
    function increment() {
      count.value++;
    }
    
    return {
      count, 
      user,
      doubleCount,
      increment
    };
  }
}
```

## 网络知识

### 14. 跨域问题及详细解决方案

跨域请求指浏览器的同源策略(Same-origin policy)阻止网页请求与当前网页不同源的资源。同源指相同的协议(protocol), 域名(domain), 端口(port)。

#### 同源策略的限制

1. 无法跨域读取Cookie、LocalStorage和IndexedDB
2. 无法跨域访问DOM元素
3. 无法跨域发送Ajax请求（可以发送，但结果会被浏览器拦截）

#### 解决方案

##### 1. CORS（跨域资源共享）

CORS是W3C标准，是最常用且灵活的跨域解决方案。

**服务器配置**：
```javascript
// Node.js Express框架示例
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://example.com'); // 或 '*'
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // 处理OPTIONS预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  
  next();
});
```

**客户端使用**：
```javascript
// 简单请求
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data));

// 带凭证的请求
fetch('https://api.example.com/data', {
  credentials: 'include' // 包含跨域Cookie
})
  .then(response => response.json());
```

**CORS请求分类**：

- **简单请求**：满足以下条件不会触发预检请求
  - 使用GET、POST或HEAD方法
  - 仅使用标准头部字段，如Accept、Content-Type等
  - Content-Type仅限于text/plain、application/x-www-form-urlencoded、multipart/form-data

- **预检请求**：其他请求会先发送OPTIONS请求询问服务器是否允许跨域请求

##### 2. JSONP

JSONP利用`<script>`标签不受同源策略限制的特性来实现跨域请求。只支持GET请求。

**服务器代码**：
```javascript
// Node.js示例
app.get('/api/data', (req, res) => {
  const callback = req.query.callback;
  const data = { name: 'John', age: 30 };
  res.send(`${callback}(${JSON.stringify(data)})`);
});
```

**客户端代码**：
```javascript
// 原生JS实现
function jsonp(url, callback) {
  const script = document.createElement('script');
  const callbackName = 'jsonp_' + Date.now();
  
  // 定义回调函数
  window[callbackName] = function(data) {
    callback(data);
    document.body.removeChild(script);
    delete window[callbackName];
  };
  
  // 准备URL
  const separator = url.includes('?') ? '&' : '?';
  script.src = `${url}${separator}callback=${callbackName}`;
  
  // 发送请求
  document.body.appendChild(script);
}

// 使用
jsonp('https://api.example.com/data', function(data) {
  console.log('Data received:', data);
});
```

**jQuery实现**：
```javascript
$.ajax({
  url: 'https://api.example.com/data',
  dataType: 'jsonp',
  success: function(data) {
    console.log('Data received:', data);
  }
});
```

##### 3. 代理服务器

通过同源的服务器作为中间件代理请求目标接口。

**Node.js代理服务器示例**：
```javascript
const http = require('http');
const httpProxy = require('http-proxy');

// 创建一个代理服务器实例
const proxy = httpProxy.createProxyServer({});

// 处理代理错误
proxy.on('error', (err, req, res) => {
  console.error('代理请求错误:', err);
  res.writeHead(500, { 'Content-Type': 'text/plain' });
  res.end('代理请求发生错误');
});

// 创建HTTP服务器
const server = http.createServer((req, res) => {
  // 设置CORS头信息
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  // 处理OPTIONS请求
  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }
  
  // 将请求转发到目标服务器
  const target = 'http://target-server.com';
  console.log(`代理请求: ${req.url} -> ${target}${req.url}`);
  
  proxy.web(req, res, { target });
});

// 设置监听端口
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`代理服务器运行在 http://localhost:${PORT}`);
});