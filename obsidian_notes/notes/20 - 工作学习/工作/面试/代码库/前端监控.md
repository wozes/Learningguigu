做好前端监控需要从多个维度来考虑，以下是一个完整的前端监控方案：

## 1. 错误监控

### JavaScript 错误捕获

```javascript
// 全局错误监控
window.addEventListener('error', (event) => {
  const errorInfo = {
    type: 'javascript',
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    stack: event.error?.stack,
    timestamp: Date.now(),
    userAgent: navigator.userAgent,
    url: window.location.href
  }
  
  sendErrorReport(errorInfo)
})

// Promise 错误捕获
window.addEventListener('unhandledrejection', (event) => {
  const errorInfo = {
    type: 'promise',
    message: event.reason.message || event.reason,
    stack: event.reason.stack,
    timestamp: Date.now(),
    url: window.location.href
  }
  
  sendErrorReport(errorInfo)
})

// React 错误边界
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    const errorData = {
      type: 'react',
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: Date.now()
    }
    
    sendErrorReport(errorData)
  }
  
  render() {
    if (this.state.hasError) {
      return <ErrorFallback />
    }
    return this.props.children
  }
}
```

### 资源加载错误

```javascript
// 监控资源加载失败
window.addEventListener('error', (event) => {
  if (event.target !== window) {
    const errorInfo = {
      type: 'resource',
      tagName: event.target.tagName,
      src: event.target.src || event.target.href,
      message: 'Resource load failed',
      timestamp: Date.now()
    }
    
    sendErrorReport(errorInfo)
  }
}, true)
```

## 2. 性能监控

### 页面性能指标

```javascript
// 核心性能指标监控
class PerformanceMonitor {
  constructor() {
    this.observer = null
    this.metrics = {}
  }
  
  // 监控 Core Web Vitals
  observeWebVitals() {
    // LCP (Largest Contentful Paint)
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries()
      const lastEntry = entries[entries.length - 1]
      this.metrics.lcp = lastEntry.startTime
      this.reportMetric('lcp', lastEntry.startTime)
    }).observe({ entryTypes: ['largest-contentful-paint'] })
    
    // FID (First Input Delay)
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries()
      entries.forEach(entry => {
        this.metrics.fid = entry.processingStart - entry.startTime
        this.reportMetric('fid', this.metrics.fid)
      })
    }).observe({ entryTypes: ['first-input'] })
    
    // CLS (Cumulative Layout Shift)
    let clsValue = 0
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
        }
      }
      this.metrics.cls = clsValue
      this.reportMetric('cls', clsValue)
    }).observe({ entryTypes: ['layout-shift'] })
  }
  
  // 页面加载性能
  getPagePerformance() {
    const timing = performance.timing
    const navigation = performance.getEntriesByType('navigation')[0]
    
    return {
      // 页面加载时间
      loadTime: timing.loadEventEnd - timing.navigationStart,
      // DNS 解析时间
      dnsTime: timing.domainLookupEnd - timing.domainLookupStart,
      // TCP 连接时间
      tcpTime: timing.connectEnd - timing.connectStart,
      // 请求响应时间
      requestTime: timing.responseEnd - timing.requestStart,
      // DOM 解析时间
      domParseTime: timing.domContentLoadedEventEnd - timing.domLoading,
      // 白屏时间
      whiteScreenTime: timing.responseStart - timing.navigationStart,
      // 首屏时间
      firstScreenTime: timing.loadEventEnd - timing.navigationStart,
      // 页面类型
      navigationType: navigation?.type
    }
  }
  
  reportMetric(name, value) {
    sendMetricReport({
      metric: name,
      value: value,
      timestamp: Date.now(),
      url: window.location.href
    })
  }
}
```

### 接口性能监控

```javascript
// 拦截 XMLHttpRequest 和 fetch
class APIMonitor {
  constructor() {
    this.interceptXHR()
    this.interceptFetch()
  }
  
  interceptXHR() {
    const originalOpen = XMLHttpRequest.prototype.open
    const originalSend = XMLHttpRequest.prototype.send
    
    XMLHttpRequest.prototype.open = function(method, url) {
      this._startTime = Date.now()
      this._method = method
      this._url = url
      return originalOpen.apply(this, arguments)
    }
    
    XMLHttpRequest.prototype.send = function() {
      this.addEventListener('loadend', () => {
        const duration = Date.now() - this._startTime
        this.reportAPI({
          url: this._url,
          method: this._method,
          status: this.status,
          duration: duration,
          success: this.status >= 200 && this.status < 400
        })
      })
      
      return originalSend.apply(this, arguments)
    }
  }
  
  interceptFetch() {
    const originalFetch = window.fetch
    
    window.fetch = async function(...args) {
      const startTime = Date.now()
      const url = args[0]
      const options = args[1] || {}
      
      try {
        const response = await originalFetch.apply(this, args)
        const duration = Date.now() - startTime
        
        sendAPIReport({
          url: url,
          method: options.method || 'GET',
          status: response.status,
          duration: duration,
          success: response.ok
        })
        
        return response
      } catch (error) {
        const duration = Date.now() - startTime
        
        sendAPIReport({
          url: url,
          method: options.method || 'GET',
          status: 0,
          duration: duration,
          success: false,
          error: error.message
        })
        
        throw error
      }
    }
  }
}
```

## 3. 用户行为监控

### 页面访问统计

```javascript
class UserBehaviorMonitor {
  constructor() {
    this.startTime = Date.now()
    this.isVisible = true
    this.bindEvents()
  }
  
  bindEvents() {
    // 页面可见性变化
    document.addEventListener('visibilitychange', () => {
      this.isVisible = !document.hidden
      if (this.isVisible) {
        this.startTime = Date.now()
      } else {
        this.recordStayTime()
      }
    })
    
    // 页面卸载
    window.addEventListener('beforeunload', () => {
      this.recordStayTime()
    })
    
    // 点击事件监控
    document.addEventListener('click', (event) => {
      this.recordClick(event)
    })
  }
  
  recordStayTime() {
    const stayTime = Date.now() - this.startTime
    sendBehaviorReport({
      type: 'stayTime',
      duration: stayTime,
      url: window.location.href,
      timestamp: Date.now()
    })
  }
  
  recordClick(event) {
    const target = event.target
    const clickInfo = {
      type: 'click',
      tagName: target.tagName,
      className: target.className,
      id: target.id,
      text: target.innerText?.slice(0, 50),
      xpath: this.getXPath(target),
      timestamp: Date.now(),
      url: window.location.href
    }
    
    sendBehaviorReport(clickInfo)
  }
  
  getXPath(element) {
    if (element.id) return `//*[@id="${element.id}"]`
    if (element === document.body) return '/html/body'
    
    let ix = 0
    const siblings = element.parentNode?.childNodes || []
    for (let i = 0; i < siblings.length; i++) {
      const sibling = siblings[i]
      if (sibling === element) {
        return this.getXPath(element.parentNode) + 
               `/${element.tagName.toLowerCase()}[${ix + 1}]`
      }
      if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
        ix++
      }
    }
  }
}
```

## 4. 数据上报机制

### 智能上报策略

```javascript
class ReportManager {
  constructor() {
    this.queue = []
    this.timer = null
    this.maxQueueSize = 10
    this.reportInterval = 5000 // 5秒
    this.retryCount = 3
  }
  
  // 添加到上报队列
  addReport(data) {
    this.queue.push({
      ...data,
      timestamp: Date.now(),
      sessionId: this.getSessionId(),
      userId: this.getUserId(),
      page: window.location.href
    })
    
    // 达到队列上限或紧急错误立即上报
    if (this.queue.length >= this.maxQueueSize || data.urgent) {
      this.flush()
    } else {
      this.scheduleFlush()
    }
  }
  
  // 批量上报
  async flush() {
    if (this.queue.length === 0) return
    
    const reports = [...this.queue]
    this.queue = []
    
    try {
      await this.sendReports(reports)
    } catch (error) {
      // 上报失败，重新加入队列重试
      this.handleRetry(reports)
    }
  }
  
  async sendReports(reports, retryCount = 0) {
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        reports: reports,
        meta: {
          userAgent: navigator.userAgent,
          timestamp: Date.now(),
          url: window.location.href
        }
      })
    }
    
    // 使用 sendBeacon 或 fetch
    if (navigator.sendBeacon && retryCount === 0) {
      const success = navigator.sendBeacon('/api/monitor', options.body)
      if (!success) throw new Error('sendBeacon failed')
    } else {
      const response = await fetch('/api/monitor', options)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
    }
  }
  
  scheduleFlush() {
    if (this.timer) return
    
    this.timer = setTimeout(() => {
      this.flush()
      this.timer = null
    }, this.reportInterval)
  }
  
  getSessionId() {
    let sessionId = sessionStorage.getItem('monitor_session_id')
    if (!sessionId) {
      sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
      sessionStorage.setItem('monitor_session_id', sessionId)
    }
    return sessionId
  }
}
```

## 5. 监控 SDK 封装

```javascript
class FrontendMonitor {
  constructor(options = {}) {
    this.options = {
      dsn: '',
      environment: 'production',
      sampleRate: 1.0,
      enablePerformance: true,
      enableBehavior: true,
      enableError: true,
      ...options
    }
    
    this.reportManager = new ReportManager()
    this.init()
  }
  
  init() {
    if (Math.random() > this.options.sampleRate) return
    
    if (this.options.enableError) {
      this.initErrorMonitor()
    }
    
    if (this.options.enablePerformance) {
      this.initPerformanceMonitor()
    }
    
    if (this.options.enableBehavior) {
      this.initBehaviorMonitor()
    }
  }
  
  // 手动上报错误
  captureException(error, extra = {}) {
    this.reportManager.addReport({
      type: 'manual_error',
      message: error.message,
      stack: error.stack,
      extra: extra,
      urgent: true
    })
  }
  
  // 手动上报信息
  captureMessage(message, level = 'info', extra = {}) {
    this.reportManager.addReport({
      type: 'message',
      message: message,
      level: level,
      extra: extra
    })
  }
  
  // 设置用户信息
  setUser(userInfo) {
    this.userInfo = userInfo
  }
  
  // 设置自定义标签
  setTag(key, value) {
    this.tags = this.tags || {}
    this.tags[key] = value
  }
}

// 使用方式
const monitor = new FrontendMonitor({
  dsn: 'https://your-monitor-api.com',
  environment: 'production',
  sampleRate: 0.1, // 10% 采样率
  enablePerformance: true,
  enableBehavior: true
})

// 设置用户信息
monitor.setUser({
  id: '12345',
  username: 'john_doe',
  email: 'john@example.com'
})

// 手动上报
monitor.captureException(new Error('Something went wrong'), {
  feature: 'checkout',
  step: 'payment'
})
```

## 6. 监控数据分析

在后端，可以对收集到的数据进行分析：

- **错误分析**：错误率、错误分布、影响用户数
- **性能分析**：页面加载时间趋势、API 响应时间分析
- **用户行为分析**：页面流转路径、功能使用频率
- **告警机制**：错误率超阈值、性能指标异常时及时通知

这样的监控方案可以帮助你全面了解前端应用的运行状况，快速定位和解决问题。