应用缓存（Application Cache，也称AppCache）是HTML5引入的一项技术，用于让Web应用在离线状态下也能正常工作。不过需要注意的是，AppCache已被废弃，现代开发主要使用Service Worker来实现类似功能。

## 应用缓存（AppCache）- 已废弃

### 基本概念

AppCache通过manifest文件定义需要缓存的资源，浏览器会自动下载并缓存这些资源。

### 使用方法

```html
<!DOCTYPE html>
<html manifest="cache.manifest">
<head>
    <title>离线应用</title>
</head>
<body>
    <!-- 页面内容 -->
</body>
</html>
```

```
# cache.manifest
CACHE MANIFEST
# 版本 1.0

# 需要缓存的文件
CACHE:
index.html
style.css
script.js
images/logo.png

# 总是从网络获取的文件
NETWORK:
api/
*.php

# 离线时的替代页面
FALLBACK:
/ offline.html
images/ images/placeholder.png
```

### 废弃原因

- 缓存行为不够灵活
- 更新机制复杂且容易出错
- 调试困难
- 安全性问题

## 现代缓存解决方案

### 1. Service Worker（推荐）

Service Worker是现代Web应用离线缓存的标准解决方案。

```javascript
// 注册Service Worker
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
        .then(registration => {
            console.log('SW注册成功:', registration);
        })
        .catch(error => {
            console.log('SW注册失败:', error);
        });
}
```

```javascript
// sw.js - Service Worker文件
const CACHE_NAME = 'my-app-v1';
const urlsToCache = [
    '/',
    '/style.css',
    '/script.js',
    '/images/logo.png'
];

// 安装事件 - 缓存资源
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                return cache.addAll(urlsToCache);
            })
    );
});

// 拦截网络请求
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // 缓存命中，返回缓存内容
                if (response) {
                    return response;
                }
                // 否则发起网络请求
                return fetch(event.request);
            })
    );
});
```

### 2. 浏览器缓存策略

**HTTP缓存头**：

```javascript
// 设置缓存头
app.get('/api/data', (req, res) => {
    res.set({
        'Cache-Control': 'public, max-age=3600', // 缓存1小时
        'ETag': 'W/"123456"',
        'Last-Modified': new Date().toUTCString()
    });
    res.json(data);
});
```

**Cache-Control选项**：

- `no-cache`：每次使用前验证
- `no-store`：不缓存
- `public`：可被所有缓存
- `private`：只能被浏览器缓存
- `max-age=3600`：缓存有效期（秒）

### 3. 本地存储

**localStorage**：

```javascript
// 存储数据
localStorage.setItem('userData', JSON.stringify(userData));

// 读取数据
const userData = JSON.parse(localStorage.getItem('userData'));

// 删除数据
localStorage.removeItem('userData');
```

**sessionStorage**：

```javascript
// 会话级存储，关闭标签页后清除
sessionStorage.setItem('tempData', 'value');
```

**IndexedDB**：

```javascript
// 大容量结构化数据存储
const request = indexedDB.open('MyDB', 1);

request.onsuccess = event => {
    const db = event.target.result;
    const transaction = db.transaction(['users'], 'readwrite');
    const store = transaction.objectStore('users');
    
    store.add({ id: 1, name: 'John', email: 'john@example.com' });
};
```

## 缓存策略

### Cache First（缓存优先）

```javascript
// 优先使用缓存，缓存失效时请求网络
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                return response || fetch(event.request);
            })
    );
});
```

### Network First（网络优先）

```javascript
// 优先请求网络，失败时使用缓存
self.addEventListener('fetch', event => {
    event.respondWith(
        fetch(event.request)
            .catch(() => {
                return caches.match(event.request);
            })
    );
});
```

### Stale While Revalidate（过期重新验证）

```javascript
// 立即返回缓存，同时在后台更新
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.open(CACHE_NAME).then(cache => {
            return fetch(event.request).then(response => {
                cache.put(event.request, response.clone());
                return response;
            }).catch(() => {
                return cache.match(event.request);
            });
        })
    );
});
```

## 最佳实践

**版本管理**：为缓存使用版本号，便于更新。

**选择性缓存**：只缓存必要的资源，避免存储过多数据。

**更新策略**：设计合理的缓存更新和失效机制。

**错误处理**：处理缓存失败和网络错误的情况。

**用户控制**：提供清除缓存的选项给用户。

现代Web开发中，Service Worker配合合适的缓存策略是实现应用缓存的最佳方案，能够提供更好的性能和用户体验。