# Vue 3 组件传值方式详解

Vue 3 提供了多种组件间传值的方式，每种方式都有其适用场景。本文档将详细介绍各种传值方式及其使用方法。

## 1. Props（父传子）

Props 是最常用的父组件向子组件传值方式，用于单向数据流传递。

### 基本用法

**父组件：**

```vue
<template>
  <ChildComponent :message="parentMessage" :count="number" />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const parentMessage = ref('Hello from parent')
const number = ref(42)
</script>
```

**子组件：**

```vue
<template>
  <div>
    <p>{{ message }}</p>
    <p>{{ count }}</p>
  </div>
</template>

<script setup>
// 定义接收的 props
const props = defineProps({
  message: String,
  count: {
    type: Number,
    default: 0
  }
})
</script>
```

### Props 类型定义

```vue
<script setup>
// 简单定义
const props = defineProps(['title', 'likes', 'isPublished'])

// 带类型的定义
const props = defineProps({
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise
})

// 详细定义（推荐）
const props = defineProps({
  title: {
    type: String,
    required: true
  },
  likes: {
    type: Number,
    default: 0
  },
  isPublished: {
    type: Boolean,
    default: false
  }
})
</script>
```

## 2. Emit（子传父）

Emit 用于子组件向父组件发送数据或事件。

### 基本用法

**子组件：**

```vue
<template>
  <div>
    <button @click="sendToParent">发送给父组件</button>
    <input @input="handleInput" />
  </div>
</template>

<script setup>
const emit = defineEmits(['update-data', 'custom-event'])

const sendToParent = () => {
  emit('update-data', '来自子组件的数据')
  emit('custom-event', { id: 1, name: 'test' })
}

const handleInput = (event) => {
  emit('update-data', event.target.value)
}
</script>
```

**父组件：**

```vue
<template>
  <ChildComponent 
    @update-data="handleUpdate" 
    @custom-event="handleCustom" 
  />
</template>

<script setup>
const handleUpdate = (data) => {
  console.log('收到数据:', data)
}

const handleCustom = (payload) => {
  console.log('自定义事件:', payload)
}
</script>
```

### Emit 验证

```vue
<script setup>
const emit = defineEmits({
  // 无验证
  click: null,
  
  // 验证 submit 事件
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  }
})

const submitForm = () => {
  emit('submit', { email: 'user@example.com', password: '123456' })
}
</script>
```

## 3. v-model（双向绑定）

v-model 实现父子组件数据的双向同步，是 Props + Emit 的语法糖。

### 单个 v-model

**子组件：**

```vue
<template>
  <input 
    :value="modelValue" 
    @input="updateValue" 
    placeholder="输入内容"
  />
</template>

<script setup>
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

const updateValue = (event) => {
  emit('update:modelValue', event.target.value)
}
</script>
```

**父组件：**

```vue
<template>
  <ChildComponent v-model="inputValue" />
  <p>当前值: {{ inputValue }}</p>
</template>

<script setup>
import { ref } from 'vue'
const inputValue = ref('')
</script>
```

### 多个 v-model

**子组件：**

```vue
<template>
  <div>
    <input 
      :value="firstName" 
      @input="updateFirstName" 
      placeholder="名字"
    />
    <input 
      :value="lastName" 
      @input="updateLastName" 
      placeholder="姓氏"
    />
  </div>
</template>

<script setup>
const props = defineProps(['firstName', 'lastName'])
const emit = defineEmits(['update:firstName', 'update:lastName'])

const updateFirstName = (event) => {
  emit('update:firstName', event.target.value)
}

const updateLastName = (event) => {
  emit('update:lastName', event.target.value)
}
</script>
```

**父组件：**

```vue
<template>
  <UserName 
    v-model:first-name="first" 
    v-model:last-name="last" 
  />
  <p>全名: {{ first }} {{ last }}</p>
</template>

<script setup>
import { ref } from 'vue'
const first = ref('')
const last = ref('')
</script>
```

## 4. Provide/Inject（跨层级传值）

Provide/Inject 用于祖先组件向后代组件传值，无需逐层传递 props。

### 基本用法

**祖先组件：**

```vue
<template>
  <div>
    <button @click="toggleTheme">切换主题</button>
    <ChildComponent />
  </div>
</template>

<script setup>
import { provide, ref } from 'vue'

const theme = ref('dark')
const user = ref({ name: 'John', id: 1 })

// 提供数据
provide('theme', theme)
provide('user', user)

const toggleTheme = () => {
  theme.value = theme.value === 'dark' ? 'light' : 'dark'
}
</script>
```

**后代组件：**

```vue
<template>
  <div :class="`theme-${theme}`">
    <p>当前主题: {{ theme }}</p>
    <p>用户: {{ user.name }}</p>
  </div>
</template>

<script setup>
import { inject } from 'vue'

// 注入数据
const theme = inject('theme')
const user = inject('user', { name: 'Guest', id: 0 }) // 第二个参数是默认值
</script>

<style scoped>
.theme-dark {
  background: #333;
  color: white;
}

.theme-light {
  background: #fff;
  color: black;
}
</style>
```

### 响应式 Provide/Inject

```vue
<script setup>
import { provide, ref, readonly } from 'vue'

const count = ref(0)
const increment = () => count.value++

// 提供响应式数据
provide('count', readonly(count))
provide('increment', increment)
</script>
```

## 5. 状态管理（Pinia）

对于复杂应用，推荐使用 Pinia 进行全局状态管理。

### Pinia Store 定义

```javascript
// stores/user.js
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    name: '',
    email: '',
    isLoggedIn: false
  }),
  
  getters: {
    fullInfo: (state) => `${state.name} (${state.email})`
  },
  
  actions: {
    updateUser(userData) {
      this.name = userData.name
      this.email = userData.email
    },
    
    login() {
      this.isLoggedIn = true
    },
    
    logout() {
      this.isLoggedIn = false
      this.name = ''
      this.email = ''
    }
  }
})
```

### 组件中使用 Pinia

```vue
<template>
  <div>
    <div v-if="userStore.isLoggedIn">
      <p>欢迎, {{ userStore.fullInfo }}</p>
      <button @click="logout">登出</button>
    </div>
    <div v-else>
      <button @click="login">登录</button>
    </div>
  </div>
</template>

<script setup>
import { useUserStore } from '@/stores/user'

const userStore = useUserStore()

const login = () => {
  userStore.updateUser({ 
    name: 'Alice', 
    email: 'alice@example.com' 
  })
  userStore.login()
}

const logout = () => {
  userStore.logout()
}
</script>
```

## 6. Ref 引用（直接访问子组件）

通过模板引用，父组件可以直接访问子组件的方法和数据。

### 基本用法

**子组件：**

```vue
<template>
  <div>
    <p>计数: {{ count }}</p>
    <button @click="increment">增加</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const count = ref(0)
const message = ref('Hello from child')

const increment = () => count.value++
const reset = () => count.value = 0
const getMessage = () => message.value

// 暴露给父组件
defineExpose({
  count,
  increment,
  reset,
  getMessage
})
</script>
```

**父组件：**

```vue
<template>
  <div>
    <ChildComponent ref="childRef" />
    <button @click="callChild">调用子组件方法</button>
    <button @click="resetChild">重置子组件</button>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue'
import ChildComponent from './ChildComponent.vue'

const childRef = ref()

const callChild = async () => {
  await nextTick() // 确保组件已挂载
  childRef.value.increment()
  console.log('子组件计数:', childRef.value.count)
  console.log('子组件消息:', childRef.value.getMessage())
}

const resetChild = () => {
  childRef.value.reset()
}
</script>
```

## 7. 事件总线（Event Bus）

对于非父子组件间的通信，可以使用事件总线模式。

### 创建事件总线

```javascript
// utils/eventBus.js
import { ref } from 'vue'

class EventBus {
  constructor() {
    this.events = {}
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data))
    }
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = []
    }
    this.events[event].push(callback)
  }

  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback)
    }
  }
}

export const eventBus = new EventBus()
```

### 使用事件总线

**发送事件的组件：**

```vue
<template>
  <button @click="sendMessage">发送消息</button>
</template>

<script setup>
import { eventBus } from '@/utils/eventBus'

const sendMessage = () => {
  eventBus.emit('user-message', { 
    text: 'Hello from component A', 
    timestamp: Date.now() 
  })
}
</script>
```

**接收事件的组件：**

```vue
<template>
  <div>
    <p v-for="msg in messages" :key="msg.timestamp">
      {{ msg.text }}
    </p>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import { eventBus } from '@/utils/eventBus'

const messages = ref([])

const handleMessage = (data) => {
  messages.value.push(data)
}

onMounted(() => {
  eventBus.on('user-message', handleMessage)
})

onUnmounted(() => {
  eventBus.off('user-message', handleMessage)
})
</script>
```

## 使用场景对比

| 传值方式       | 适用场景       | 优点                   | 缺点                   |
| -------------- | -------------- | ---------------------- | ---------------------- |
| Props          | 父传子         | 简单直观，单向数据流   | 只能父传子             |
| Emit           | 子传父         | 事件驱动，解耦         | 只能子传父             |
| v-model        | 双向绑定       | 语法简洁，适合表单     | 限制较多               |
| Provide/Inject | 跨层级传递     | 避免逐层传递           | 不够直观，难以追踪     |
| Pinia/Vuex     | 全局状态管理   | 统一管理，开发工具支持 | 增加复杂度             |
| Ref            | 直接访问子组件 | 功能强大               | 破坏组件封装           |
| Event Bus      | 任意组件通信   | 灵活                   | 难以维护，容易内存泄漏 |

## 最佳实践

1. **优先使用 Props 和 Emit**：对于直接的父子组件通信
2. **合理使用 v-model**：适用于表单组件和需要双向绑定的场景
3. **谨慎使用 Provide/Inject**：适合主题、语言等全局配置
4. **复杂状态用 Pinia**：多组件共享状态时的首选
5. **避免过度使用 Ref**：会破坏组件的封装性
6. **慎用 Event Bus**：容易造成维护困难

选择合适的传值方式能够让你的 Vue 3 应用更加清晰、可维护。