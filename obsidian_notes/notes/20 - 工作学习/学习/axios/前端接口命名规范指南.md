# 前端接口命名规范指南

接口名称应该和后端对应吗？

## 🤔 两种主流观点

### 观点1：应该对应 ✅

**优点**：

- 前后端沟通更清晰
- 定位问题更容易
- API 文档和代码一致

**缺点**：

- 前端可能被后端 API 设计绑架
- 后端 API 命名不够语义化时前端也要跟着

### 观点2：不必完全对应 ✅

**优点**：

- 前端可以用更符合业务逻辑的命名
- 更好的代码可读性
- 解耦前后端

**缺点**：

- 需要维护映射关系
- 新人理解成本稍高

## 💡 推荐方案：混合策略

根据不同情况采用不同策略：

### 1. URL 路径：建议对应

```typescript
// 后端 API: GET /api/categories
// 前端接口函数命名
export const categoryApi = {
  getCategories: () => httpClient.get('/api/categories'),
  getCategoryById: (id: number) => httpClient.get(`/api/categories/${id}`),
  createCategory: (data: any) => httpClient.post('/api/categories', data),
  updateCategory: (id: number, data: any) => httpClient.put(`/api/categories/${id}`, data),
  deleteCategory: (id: number) => httpClient.delete(`/api/categories/${id}`)
}
```

### 2. 数据结构：看情况

根据后端 API 的质量决定：

#### 情况A：后端 API 设计合理

```typescript
// 后端返回
{
  "code": 200,
  "message": "success",
  "data": {
    "categories": [
      {
        "id": 1,
        "name": "电子产品",
        "parent_id": null,
        "is_active": true,
        "created_at": "2024-01-01T10:00:00Z"
      }
    ]
  }
}

// 前端接口：直接对应
interface Category {
  id: number;
  name: string;
  parent_id: number | null;
  is_active: boolean;
  created_at: string;
}

interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}
```

#### 情况B：后端 API 设计不理想

```typescript
// 后端返回（字段命名不规范）
{
  "code": 200,
  "msg": "ok",
  "result": {
    "cat_list": [
      {
        "cat_id": 1,
        "cat_name": "电子产品",
        "p_id": null,
        "status": 1,
        "add_time": "2024-01-01 10:00:00"
      }
    ]
  }
}

// 前端接口：两种处理方式

// 方式1：直接对应（不推荐，但简单）
interface BackendCategory {
  cat_id: number;
  cat_name: string;
  p_id: number | null;
  status: number;
  add_time: string;
}

// 方式2：转换映射（推荐）
interface Category {
  id: number;
  name: string;
  parentId: number | null;
  isActive: boolean;
  createdAt: string;
}

// 在 API 层做转换
const categoryApi = {
  getCategories: async (): Promise<Category[]> => {
    const response = await httpClient.get<BackendResponse<BackendCategory[]>>('/api/categories');
    
    // 转换数据结构
    return response.result.cat_list.map(item => ({
      id: item.cat_id,
      name: item.cat_name,
      parentId: item.p_id,
      isActive: item.status === 1,
      createdAt: item.add_time
    }));
  }
}
```

## 🎯 实际项目建议

### 1. 团队规范优先

```typescript
// 如果团队有统一规范，优先遵循
// 例如：团队决定前端字段全部用 camelCase
interface User {
  userId: number;      // 后端：user_id
  userName: string;    // 后端：user_name
  createdAt: string;   // 后端：created_at
}
```

### 2. 分层处理

```typescript
// api/types/backend.ts - 后端原始数据结构
export interface BackendUser {
  user_id: number;
  user_name: string;
  email: string;
  created_at: string;
}

// types/user.ts - 前端业务数据结构
export interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;  // 注意：转换成 Date 对象
}

// api/user.ts - API 层做转换
import { BackendUser } from './types/backend';
import { User } from '@/types/user';

export const userApi = {
  getUsers: async (): Promise<User[]> => {
    const response = await httpClient.get<ApiResponse<BackendUser[]>>('/api/users');
    
    return response.data.map(backendUser => ({
      id: backendUser.user_id,
      name: backendUser.user_name,
      email: backendUser.email,
      createdAt: new Date(backendUser.created_at)
    }));
  }
}
```

### 3. 实用工具函数

```typescript
// utils/transform.ts
export class ApiTransformer {
  // 下划线转驼峰
  static toCamelCase(obj: any): any {
    if (Array.isArray(obj)) {
      return obj.map(item => this.toCamelCase(item));
    }
    
    if (obj && typeof obj === 'object') {
      const result: any = {};
      for (const key in obj) {
        const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
        result[camelKey] = this.toCamelCase(obj[key]);
      }
      return result;
    }
    
    return obj;
  }
  
  // 驼峰转下划线
  static toSnakeCase(obj: any): any {
    if (Array.isArray(obj)) {
      return obj.map(item => this.toSnakeCase(item));
    }
    
    if (obj && typeof obj === 'object') {
      const result: any = {};
      for (const key in obj) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        result[snakeKey] = this.toSnakeCase(obj[key]);
      }
      return result;
    }
    
    return obj;
  }
}

// 使用
const backendData = { user_id: 1, user_name: '张三' };
const frontendData = ApiTransformer.toCamelCase(backendData);
// 结果: { userId: 1, userName: '张三' }
```

## 🔧 你的项目建议

根据你的代码，我建议：

### 1. 当前方案（简单直接）

```typescript
// 直接对应后端字段
interface Category {
  id: number;
  name: string;
  parent_id?: number;  // 对应后端 parent_id
  level: number;
  sort_order: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export const categoryApi = {
  getCategories: async (parentId?: number): Promise<Category[]> => {
    const response = await httpClient.get<ApiResponse<{ categories: Category[] }>>(
      '/public/categories',
      { params: { parent_id: parentId } }
    );
    return response.data.categories;
  }
}
```

### 2. 改进方案（推荐）

```typescript
// 前端业务数据结构（更符合前端命名习惯）
interface Category {
  id: number;
  name: string;
  parentId?: number;     // 改为 camelCase
  level: number;
  sortOrder: number;     // 改为 camelCase
  isActive: boolean;     // 改为 camelCase
  createdAt: string;     // 改为 camelCase
  updatedAt: string;     // 改为 camelCase
  children?: Category[];
}

// 后端原始数据结构
interface BackendCategory {
  id: number;
  name: string;
  parent_id?: number;
  level: number;
  sort_order: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

// API 层做转换
export const categoryApi = {
  getCategories: async (parentId?: number): Promise<Category[]> => {
    const response = await httpClient.get<ApiResponse<{ categories: BackendCategory[] }>>(
      '/public/categories',
      { params: { parent_id: parentId } }
    );
    
    return response.data.categories.map(item => ({
      id: item.id,
      name: item.name,
      parentId: item.parent_id,
      level: item.level,
      sortOrder: item.sort_order,
      isActive: item.is_active,
      createdAt: item.created_at,
      updatedAt: item.updated_at
    }));
  }
}
```

## 📋 决策矩阵

| 情况                          | 建议         | 原因                 |
| ----------------------------- | ------------ | -------------------- |
| 后端 API 规范，字段命名合理   | 直接对应     | 简单直接，沟通成本低 |
| 后端 API 不规范，字段命名混乱 | 转换映射     | 提高前端代码质量     |
| 团队有统一规范                | 遵循团队规范 | 保持一致性           |
| 项目紧急，时间不够            | 直接对应     | 快速开发             |
| 长期维护项目                  | 转换映射     | 便于后续维护         |

## 💡 总结

**我的建议**：

1. **优先遵循团队规范**

2. **URL 路径建议对应后端**

3. 数据结构看情况

   ：

   - 后端规范 → 直接对应
   - 后端不规范 → 转换映射

4. **项目初期可以简单对应，后期再优化**

对于你的项目，如果后端 API 设计合理，建议先直接对应，项目稳定后再考虑是否需要转换层。

你们团队有相关规范吗？还是我帮你制定一个适合的方案？