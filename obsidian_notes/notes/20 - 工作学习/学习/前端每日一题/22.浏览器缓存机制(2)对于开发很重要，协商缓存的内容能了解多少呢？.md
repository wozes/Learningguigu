# Problem: 浏览器缓存机制(2)对于开发很重要，协商缓存的内容能了解多少呢？

*[interview]: start
    好的，从前端工程师的角度来详细讲解协商缓存：

## 协商缓存的触发时机
作为前端工程师，你需要知道协商缓存在什么时候会被触发：
- 强缓存过期后（Cache-Control: max-age过期）
- 首次访问资源
- 用户手动刷新页面（F5）
- 设置了no-cache但允许协商缓存

## 两种协商缓存机制详解

### 1. Last-Modified / If-Modified-Since
```http
# 首次请求响应头
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
Cache-Control: no-cache

# 再次请求头
GET /api/data.json HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT

# 服务器响应（未修改）
HTTP/1.1 304 Not Modified
```

### 2. ETag / If-None-Match（更精确）
```http
# 首次请求响应头
HTTP/1.1 200 OK
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Cache-Control: no-cache

# 再次请求头
GET /api/data.json HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# 服务器响应（未修改）
HTTP/1.1 304 Not Modified
```

## 前端开发中的实际应用

### 静态资源缓存策略
```javascript
// webpack配置中，通常这样处理静态资源
module.exports = {
  output: {
    filename: '[name].[contenthash].js', // 文件内容变化时hash变化
    publicPath: '/static/'
  }
}
```

### API请求中的协商缓存
```javascript
// axios拦截器处理ETag
axios.interceptors.response.use(response => {
  // 存储ETag
  if (response.headers.etag) {
    localStorage.setItem(`etag_${response.config.url}`, response.headers.etag);
  }
  return response;
});

axios.interceptors.request.use(config => {
  // 添加If-None-Match头
  const etag = localStorage.getItem(`etag_${config.url}`);
  if (etag) {
    config.headers['If-None-Match'] = etag;
  }
  return config;
});
```

## 开发调试技巧

### Chrome DevTools中观察协商缓存
1. **Network面板**：
   - 304状态码表示协商缓存命中
   - Size列显示"(from disk cache)"或实际字节数
   - Response Headers中查看ETag/Last-Modified

2. **禁用缓存调试**：
   ```javascript
   // 开发环境禁用缓存
   if (process.env.NODE_ENV === 'development') {
     axios.defaults.headers.common['Cache-Control'] = 'no-cache';
   }
   ```

### 常见的缓存控制组合
```http
# 协商缓存 + 短期强缓存
Cache-Control: max-age=60, must-revalidate
ETag: "abc123"

# 纯协商缓存
Cache-Control: no-cache
ETag: "abc123"

# 强缓存优先，过期后协商
Cache-Control: max-age=3600
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
```

## 前端性能优化应用

### 1. 版本控制策略
```javascript
// 对于频繁更新的API，使用ETag
fetch('/api/user-data', {
  headers: {
    'If-None-Match': lastETag
  }
}).then(response => {
  if (response.status === 304) {
    // 使用本地缓存数据
    return getCachedData();
  }
  // 更新缓存
  return response.json();
});
```

### 2. 资源更新检测
```javascript
// 检测资源是否需要更新
async function checkResourceUpdate(url, lastModified) {
  const response = await fetch(url, {
    method: 'HEAD', // 只获取头信息
    headers: {
      'If-Modified-Since': lastModified
    }
  });
  
  return response.status !== 304; // true表示需要更新
}
```

## 实际项目中的最佳实践

### 1. 不同资源的缓存策略
- **HTML文件**：协商缓存（ETag）
- **CSS/JS文件**：强缓存 + 文件名hash
- **API数据**：协商缓存（ETag）
- **图片资源**：长期强缓存

### 2. 缓存失效策略
```javascript
// 强制刷新缓存的方法
function forceRefresh() {
  // 添加时间戳绕过缓存
  const timestamp = Date.now();
  fetch(`/api/data?t=${timestamp}`);
  
  // 或者使用Cache-Control
  fetch('/api/data', {
    headers: {
      'Cache-Control': 'no-cache'
    }
  });
}
```

## 注意事项
1. **ETag优先级高于Last-Modified**：同时存在时，服务器优先使用ETag
2. **协商缓存仍需网络请求**：虽然可能不传输文件内容，但仍有网络开销
3. **服务器配置很重要**：需要后端正确实现协商缓存逻辑
4. **移动端注意流量**：304响应也会消耗少量流量

理解协商缓存有助于你优化前端应用的加载性能，特别是在处理API数据和静态资源时。

协商缓存是浏览器缓存机制中非常重要的一部分，让我用通俗的方式给你讲解：

## 什么是协商缓存
协商缓存就像是你和服务器之间的"对暗号"过程。浏览器先问服务器："我这个文件还能用吗？"，服务器回答："能用，别下载了"或者"过期了，给你新的"。

## 工作流程
1. 浏览器发请求时带上文件的"身份证"（标识符）
2. 服务器检查文件是否有更新
3. 没更新：返回304状态码，告诉浏览器用本地缓存
4. 有更新：返回200状态码和新文件

## 两种协商方式

**Last-Modified 方式（按时间判断）**
- 服务器告诉浏览器文件的最后修改时间
- 下次请求时浏览器问："我这个是XX时间的，还能用吗？"
- 服务器对比时间决定是否更新

**ETag 方式（按内容判断）**
- 服务器给文件生成一个唯一的"指纹"（哈希值）
- 下次请求时浏览器问："我这个指纹是XXX，还能用吗？"
- 服务器对比指纹决定是否更新

## 实际例子
```
第一次访问：
浏览器：我要index.js
服务器：给你文件 + ETag: "abc123"

第二次访问：
浏览器：我要index.js，我有ETag: "abc123"的版本
服务器：没变化，返回304，用你本地的

文件更新后：
浏览器：我要index.js，我有ETag: "abc123"的版本  
服务器：文件更新了，返回200 + 新文件 + 新ETag: "def456"
```

## 开发中的好处
- **省流量**：没更新就不重新下载
- **加载快**：直接用本地缓存
- **减轻服务器压力**：避免重复传输相同文件
- **用户体验好**：页面加载更快

## 注意事项
- ETag比Last-Modified更准确（有些文件时间变了但内容没变）
- 协商缓存每次都要发请求到服务器，只是可能不下载文件
- 和强缓存配合使用效果更好

这就是为什么有时候你刷新网页，开发者工具显示某些文件是304状态码的原因！
*[interview]: end
